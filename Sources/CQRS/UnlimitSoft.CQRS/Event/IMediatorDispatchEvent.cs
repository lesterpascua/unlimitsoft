using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using UnlimitSoft.CQRS.Data;
using UnlimitSoft.Event;
using UnlimitSoft.Message;
using UnlimitSoft.Web.Client;

namespace UnlimitSoft.CQRS.Event;


/// <summary>
/// Used as proxy to store versioned event generated by entities just before complete transaction
/// </summary>
public interface IMediatorDispatchEvent
{
    /// <summary>
    /// Send event to save. This operation should be perform transactional.
    /// </summary>
    /// <param name="events"></param>
    /// <param name="forceSave">If false event is wait for save in cache, else force to save event before to leave this implementation.</param>
    /// <param name="stopCreation">Indicate don't create the event in the repository. Is usefull when the event was already created</param>
    /// <param name="ct"></param>
    /// <returns></returns>
    Task DispatchEventsAsync(IEnumerable<IEvent> events, bool forceSave, bool stopCreation, CancellationToken ct = default);
    /// <summary>
    /// When all event are saved invoqued this method.
    /// </summary>
    /// <param name="events"></param>
    /// <param name="ct"></param>
    /// <returns></returns>
    ValueTask EventsDispatchedAsync(IEnumerable<IEvent> events, CancellationToken ct = default);
}
/// <summary>
/// 
/// </summary>
public abstract class MediatorDispatchEvent<TEventPayload> : IMediatorDispatchEvent
    where TEventPayload : EventPayload
{
    /// <summary>
    /// 
    /// </summary>
    /// <param name="provider"></param>
    /// <param name="directlyDispatchNotDomainEvents">If true try to dispatch not domain event directly to find if exist any procesor for it.</param>
    public MediatorDispatchEvent(IServiceProvider provider, bool directlyDispatchNotDomainEvents = true)
    {
        Provider = provider;
        DirectlyDispatchNotDomainEvents = directlyDispatchNotDomainEvents;
    }

    /// <summary>
    /// If true try to dispatch not domain event directly to find if exist any procesor for it.
    /// </summary>
    protected bool DirectlyDispatchNotDomainEvents { get; }
    /// <summary>
    /// 
    /// </summary>
    protected IServiceProvider Provider { get; }
    /// <summary>
    /// Get event dispatcher registered in the DPI
    /// </summary>
    protected virtual IEventDispatcher? EventDispatcher => Provider.GetService<IEventDispatcher>();
    /// <summary>
    /// Get event publish worker registered in the DPI
    /// </summary>
    protected virtual IEventPublishWorker? EventPublishWorker => Provider.GetService<IEventPublishWorker>();
    /// <summary>
    /// Get event repository registered in the DPI
    /// </summary>
    protected abstract IEventRepository<TEventPayload>? EventRepository { get; }


    /// <summary>
    /// Create new event using versioned event as template.
    /// </summary>
    /// <param name="event"></param>
    /// <returns></returns>
    protected abstract TEventPayload Create(IEvent @event);

    /// <inheritdoc />
    public virtual async Task DispatchEventsAsync(IEnumerable<IEvent> events, bool forceSave, bool stopCreation, CancellationToken ct)
    {
        var eventRepository = EventRepository;
        var eventsPayload = (eventRepository is not null && !stopCreation) ? new List<TEventPayload>() : null;

        foreach (var @event in events)
        {
            var payload = Create(@event);
            eventsPayload?.Add(payload);

            var eventDispatcher = EventDispatcher;
            if (eventDispatcher is null || (!@event.IsDomainEvent && !DirectlyDispatchNotDomainEvents))
                continue;

            var (response, error) = await eventDispatcher.DispatchAsync(Provider, @event, ct);
            if (error is null || error.Code == HttpStatusCode.NotFound)
                continue;

            var msg = "Error when executed events";
            throw new AggregateException(msg, error.GetBody<Exception>() ?? throw new InvalidOperationException(msg));
        }
        if (eventsPayload is not null && eventRepository is not null)
            await eventRepository.CreateAsync(eventsPayload, forceSave, ct);
    }
    /// <summary>
    /// Indicated all event already dispatchers.
    /// </summary>
    /// <param name="events"></param>
    /// <param name="ct"></param>
    /// <returns></returns>
    public virtual async ValueTask EventsDispatchedAsync(IEnumerable<IEvent> events, CancellationToken ct)
    {
        var eventRepository = EventRepository;
        if (eventRepository is not null)
            await eventRepository.SavePendingCangesAsync(ct);

        var publishWorker = EventPublishWorker;
        if (publishWorker is not null)
            await publishWorker.PublishAsync(events, ct);
    }
}

using Microsoft.Extensions.DependencyInjection;
using SoftUnlimit.CQRS.Event;
using SoftUnlimit.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoftUnlimit.CQRS.EventSourcing
{
    /// <summary>
    /// Used as proxy to store versioned event generated by entities just before complete transaction
    /// </summary>
    public interface IMediatorDispatchEventSourced
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="events"></param>
        /// <returns></returns>
        Task DispatchEventsAsync(IEnumerable<IVersionedEvent> events);
        /// <summary>
        /// When all event are saved invoqued this method.
        /// </summary>
        /// <param name="events"></param>
        /// <returns></returns>
        Task EventsDispatchedAsync(IEnumerable<IVersionedEvent> events);
    }
    /// <summary>
    /// 
    /// </summary>
    public abstract class MediatorDispatchEventSourced<TPayload> : IMediatorDispatchEventSourced
        where TPayload : class
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="provider"></param>
        /// <param name="directlyDispatchNotDomainEvents">If true try to dispatch not domain event directly to find if exist any procesor for it.</param>
        public MediatorDispatchEventSourced(IServiceProvider provider, bool directlyDispatchNotDomainEvents = true)
        {
            Provider = provider;
            DirectlyDispatchNotDomainEvents = directlyDispatchNotDomainEvents;
        }

        /// <summary>
        /// If true try to dispatch not domain event directly to find if exist any procesor for it.
        /// </summary>
        protected bool DirectlyDispatchNotDomainEvents { get; }
        /// <summary>
        /// 
        /// </summary>
        protected IServiceProvider Provider { get; }
        /// <summary>
        /// 
        /// </summary>
        protected abstract IEventDispatcher EventDispatcher { get; }
        /// <summary>
        /// 
        /// </summary>
        protected abstract IEventPublishWorker EventPublishWorker { get; }
        /// <summary>
        /// 
        /// </summary>
        protected abstract IRepository<TPayload> VersionedEventRepository { get; }

        /// <summary>
        /// Create new event using versioned event as template.
        /// </summary>
        /// <param name="event"></param>
        /// <returns></returns>
        protected abstract TPayload Create(IVersionedEvent @event);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="events"></param>
        /// <returns></returns>
        public virtual async Task DispatchEventsAsync(IEnumerable<IVersionedEvent> events)
        {
            List<TPayload> remoteEvents = new List<TPayload>();
            foreach (var @event in events)
            {
                var payload = Create(@event);
                remoteEvents.Add(payload);
                if (@event.IsDomainEvent || DirectlyDispatchNotDomainEvents)
                {
                    var responses = await EventDispatcher?.DispatchEventAsync(Provider, @event);
                    if (responses?.Success == false)
                    {
                        var exceptions = responses.ErrorEvents
                            .Select(s => (Exception)s.GetBody());
                        throw new AggregateException("Error when executed events", exceptions);
                    }
                }
            }
            await VersionedEventRepository.AddRangeAsync(remoteEvents);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="events"></param>
        /// <returns></returns>
        public virtual Task EventsDispatchedAsync(IEnumerable<IVersionedEvent> events)
        {
            EventPublishWorker?.Publish(events);
            return Task.CompletedTask;
        }
    }
}
